<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>protflow.jobstarters &mdash; ProtFlow 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=8d563738"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            ProtFlow
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../protflow.html">protflow package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ProtFlow</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">protflow.jobstarters</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for protflow.jobstarters</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">jobstarters</span>
<span class="sd">===========</span>

<span class="sd">This module, `jobstarters`, provides a set of classes and methods to facilitate the submission and management </span>
<span class="sd">of computing jobs on various job scheduling systems. JobStarters are passed to Runner objects in their .run()</span>
<span class="sd">methods to facilitate a standardized execution of commands generated by the Runner. JobStarters can also be</span>
<span class="sd">executed outside of Runner classes as is shown in the examples.</span>

<span class="sd">The JobStarter class defines a base `JobStarter` class with methods that need to be implemented by subclasses </span>
<span class="sd">to start jobs and wait for their completion.</span>

<span class="sd">Overview</span>
<span class="sd">--------</span>
<span class="sd">The module includes the following classes and methods:</span>

<span class="sd">Classes</span>
<span class="sd">-------</span>
<span class="sd">- `JobStarter`: An abstract base class that defines the interface for all jobstarters.</span>
<span class="sd">- `SbatchArrayJobstarter`: A concrete implementation of `JobStarter` for managing SLURM job arrays.</span>
<span class="sd">- `LocalJobStarter`: A concrete implementation of `JobStarter` for managing local jobs.</span>

<span class="sd">Usage</span>
<span class="sd">-----</span>
<span class="sd">To use a jobstarter, instantiate an appropriate subclass (e.g., `SbatchArrayJobstarter`) and call its `start` method with the desired commands and options. Use the `wait_for_job` method if you need to wait for job completion.</span>

<span class="sd">Example:</span>
<span class="sd">    &gt;&gt;&gt; from jobstarters import SbatchArrayJobstarter</span>
<span class="sd">    &gt;&gt;&gt; job_starter = SbatchArrayJobstarter(max_cores=50, remove_cmdfile=True)</span>
<span class="sd">    &gt;&gt;&gt; job_starter.start(cmds=[&quot;echo &#39;Hello World!&#39;&quot;], jobname=&quot;test_job&quot;, wait=True, output_path=&quot;/path/to/output&quot;)</span>

<span class="sd">Note</span>
<span class="sd">----</span>
<span class="sd">This module is designed to be extended with additional jobstarters for different scheduling systems as needed. If you want to implement your own JobStarter and need assistance, please contact any of the authors of ProtFlow for assistance. We are happy about every contribution!</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">ProcessError</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">subprocess</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<div class="viewcode-block" id="JobStarter">
<a class="viewcode-back" href="../../protflow.html#protflow.jobstarters.JobStarter">[docs]</a>
<span class="k">class</span> <span class="nc">JobStarter</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract base class for job starters.</span>

<span class="sd">    This class defines the interface for all job starters. Subclasses should implement methods</span>
<span class="sd">    to start jobs and wait for their completion. It also includes a method to set the maximum</span>
<span class="sd">    number of cores available for the jobs.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    __init__(max_cores: int = None)</span>
<span class="sd">        Initializes the JobStarter with an optional maximum number of cores.</span>
<span class="sd">    </span>
<span class="sd">    start(cmds: list, jobname: str, wait: bool, output_path: str) -&gt; None</span>
<span class="sd">        Submits a list of commands as jobs to the scheduling system. This method should be</span>
<span class="sd">        implemented by subclasses.</span>
<span class="sd">    </span>
<span class="sd">    wait_for_job(jobname: str, interval: float) -&gt; None</span>
<span class="sd">        Waits for a job to complete before proceeding. This method should be implemented</span>
<span class="sd">        by subclasses.</span>
<span class="sd">    </span>
<span class="sd">    set_max_cores(cores: int) -&gt; None</span>
<span class="sd">        Sets the maximum number of cores available for the jobs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    max_cores : int, optional</span>
<span class="sd">        The maximum number of cores that can be used for the jobs. Default is None.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NotImplementedError</span>
<span class="sd">        If the &#39;start&#39; or &#39;wait_for_job&#39; methods are not implemented in a subclass.</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    This class is designed to be extended by other classes that implement specific job</span>
<span class="sd">    scheduling systems.</span>

<span class="sd">    Example subclass implementation:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        class CustomJobStarter(JobStarter):</span>
<span class="sd">            def start(self, cmds, jobname, wait, output_path):</span>
<span class="sd">                # Implementation for starting jobs</span>
<span class="sd">                pass</span>
<span class="sd">            </span>
<span class="sd">            def wait_for_job(self, jobname, interval):</span>
<span class="sd">                # Implementation for waiting for job completion</span>
<span class="sd">                pass</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="JobStarter.__init__">
<a class="viewcode-back" href="../../protflow.html#protflow.jobstarters.JobStarter.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_cores</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the JobStarter with an optional maximum number of cores.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_cores : int, optional</span>
<span class="sd">            The maximum number of cores that can be used for the jobs. Default is None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_cores</span> <span class="o">=</span> <span class="n">max_cores</span></div>


<div class="viewcode-block" id="JobStarter.start">
<a class="viewcode-back" href="../../protflow.html#protflow.jobstarters.JobStarter.start">[docs]</a>
    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmds</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">jobname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">wait</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">output_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Submits a list of commands as jobs to the scheduling system.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cmds : list</span>
<span class="sd">            A list of commands to be submitted as jobs.</span>
<span class="sd">        jobname : str</span>
<span class="sd">            The name of the job.</span>
<span class="sd">        wait : bool</span>
<span class="sd">            Whether to wait for the job to complete before proceeding.</span>
<span class="sd">        output_path : str</span>
<span class="sd">            The path where output files should be stored.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            If this method is not implemented in a subclass.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Jobstarter &#39;start&#39; function was not overwritten!&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="JobStarter.wait_for_job">
<a class="viewcode-back" href="../../protflow.html#protflow.jobstarters.JobStarter.wait_for_job">[docs]</a>
    <span class="k">def</span> <span class="nf">wait_for_job</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jobname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">interval</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Waits for a job to complete before proceeding.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        jobname : str</span>
<span class="sd">            The name of the job to wait for.</span>
<span class="sd">        interval : float</span>
<span class="sd">            The interval (in seconds) at which to check the job status.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            If this method is not implemented in a subclass.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Jobstarter &#39;wait_for_job&#39; function was not overwritten!&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="JobStarter.set_max_cores">
<a class="viewcode-back" href="../../protflow.html#protflow.jobstarters.JobStarter.set_max_cores">[docs]</a>
    <span class="k">def</span> <span class="nf">set_max_cores</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cores</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the maximum number of cores available for the jobs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cores : int</span>
<span class="sd">            The maximum number of cores to set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_cores</span> <span class="o">=</span> <span class="n">cores</span></div>
</div>


<div class="viewcode-block" id="SbatchArrayJobstarter">
<a class="viewcode-back" href="../../protflow.html#protflow.jobstarters.SbatchArrayJobstarter">[docs]</a>
<span class="k">class</span> <span class="nc">SbatchArrayJobstarter</span><span class="p">(</span><span class="n">JobStarter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Jobstarter that manages the submission of job arrays to SLURM clusters.</span>

<span class="sd">    This class extends the `JobStarter` base class to provide functionality specific to SLURM job arrays. </span>
<span class="sd">    It handles tasks such as generating command files, submitting jobs using `sbatch`, and waiting for job </span>
<span class="sd">    completion. It also supports options for GPU usage and automatic cleanup of command files after job </span>
<span class="sd">    completion.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    __init__(max_cores: int = 100, remove_cmdfile: bool = False, options: str = None, gpus: bool = False)</span>
<span class="sd">        Initializes the SbatchArrayJobstarter with optional parameters for maximum cores, command file removal, </span>
<span class="sd">        SBATCH options, and GPU usage.</span>
<span class="sd">    </span>
<span class="sd">    start(cmds: list, jobname: str, wait: bool = True, output_path: str = &quot;./&quot;) -&gt; None</span>
<span class="sd">        Writes the commands to a command file and submits the job array to SLURM. If the number of commands </span>
<span class="sd">        exceeds the maximum allowed for a single array, it splits them into multiple arrays.</span>
<span class="sd">    </span>
<span class="sd">    parse_options(options: object) -&gt; str</span>
<span class="sd">        Parses the SBATCH options from a string or list format.</span>
<span class="sd">    </span>
<span class="sd">    set_options(options: object, gpus: int) -&gt; None</span>
<span class="sd">        Sets the SBATCH options, including GPU configuration if specified.</span>
<span class="sd">    </span>
<span class="sd">    wait_for_job(jobname: str, interval: float = 5) -&gt; None</span>
<span class="sd">        Waits for the SLURM jobs to be finished, checking the job status at regular intervals.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    max_cores : int, optional</span>
<span class="sd">        The maximum number of cores that can be used for the jobs. Default is 100.</span>
<span class="sd">    remove_cmdfile : bool, optional</span>
<span class="sd">        Whether to remove the command file after job completion. Default is False.</span>
<span class="sd">    options : str, optional</span>
<span class="sd">        Additional SBATCH options to be used when submitting jobs. Default is None.</span>
<span class="sd">    gpus : bool, optional</span>
<span class="sd">        Whether to use GPUs for the job. Default is False.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If the options parameter is not a string or list.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Example usage:</span>
<span class="sd">    </span>
<span class="sd">        &gt;&gt;&gt; from jobstarters import SbatchArrayJobstarter</span>
<span class="sd">        &gt;&gt;&gt; job_starter = SbatchArrayJobstarter(max_cores=50, remove_cmdfile=True, options=&quot;--time=10:00&quot;, gpus=True)</span>
<span class="sd">        &gt;&gt;&gt; job_starter.start(cmds=[&quot;echo &#39;Hello World!&#39;&quot;], jobname=&quot;test_job&quot;, wait=True, output_path=&quot;/path/to/output&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SbatchArrayJobstarter.__init__">
<a class="viewcode-back" href="../../protflow.html#protflow.jobstarters.SbatchArrayJobstarter.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_cores</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">remove_cmdfile</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">gpus</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the SbatchArrayJobstarter with optional parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_cores : int, optional</span>
<span class="sd">            The maximum number of cores that can be used for the jobs. Default is 100.</span>
<span class="sd">        remove_cmdfile : bool, optional</span>
<span class="sd">            Whether to remove the command file after job completion. Default is False.</span>
<span class="sd">        options : str, optional</span>
<span class="sd">            Additional SBATCH options to be used when submitting jobs. Default is None.</span>
<span class="sd">        gpus : bool, optional</span>
<span class="sd">            Whether to use GPUs for the job. Default is False.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        The options parameter must be set when the Jobstarter is created, not when the `.start` function is executed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span> <span class="c1"># runs init-function of parent class (JobStarter)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_cores</span> <span class="o">=</span> <span class="n">max_cores</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_cmdfile</span> <span class="o">=</span> <span class="n">remove_cmdfile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_options</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">gpus</span><span class="o">=</span><span class="n">gpus</span><span class="p">)</span>

        <span class="c1"># static attribute, can be changed depending on slurm settings:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slurm_max_arrayjobs</span> <span class="o">=</span> <span class="mi">1000</span></div>


<div class="viewcode-block" id="SbatchArrayJobstarter.start">
<a class="viewcode-back" href="../../protflow.html#protflow.jobstarters.SbatchArrayJobstarter.start">[docs]</a>
    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmds</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">jobname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">wait</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">output_path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;./&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes commands into a command file and starts an SBATCH job running the command file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cmds : list</span>
<span class="sd">            List of commands to be executed as part of the job array.</span>
<span class="sd">        jobname : str</span>
<span class="sd">            Name of the job.</span>
<span class="sd">        wait : bool, optional</span>
<span class="sd">            Whether to wait for the job to complete before returning. Default is True.</span>
<span class="sd">        output_path : str, optional</span>
<span class="sd">            Path where output files should be stored. Default is &quot;./&quot;.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            If the SLURM submission fails.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check if cmds is smaller than 1000. If yes, split cmds and start split array!</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cmds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">slurm_max_arrayjobs</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The commands-list you supplied is longer than self.slurm_max_arrayjobs. Your job will be subdivided into multiple arrays.&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">split_list</span><span class="p">(</span><span class="n">cmds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">slurm_max_arrayjobs</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">cmds</span><span class="o">=</span><span class="n">sublist</span><span class="p">,</span> <span class="n">jobname</span><span class="o">=</span><span class="n">jobname</span><span class="p">,</span> <span class="n">wait</span><span class="o">=</span><span class="n">wait</span><span class="p">,</span> <span class="n">output_path</span><span class="o">=</span><span class="n">output_path</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># write cmd-file</span>
        <span class="n">jobname</span> <span class="o">=</span> <span class="n">add_timestamp</span><span class="p">(</span><span class="n">jobname</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">((</span><span class="n">cmdfile</span> <span class="o">:=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">jobname</span><span class="si">}</span><span class="s2">_cmds&quot;</span><span class="p">),</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;UTF-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cmds</span><span class="p">))</span>

        <span class="c1"># write sbatch command and run</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; -vvv -e </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">jobname</span><span class="si">}</span><span class="s2">_slurm.err -o </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">jobname</span><span class="si">}</span><span class="s2">_slurm.out --open-mode=append&quot;</span>
        <span class="n">sbatch_cmd</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;sbatch -a 1-</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cmds</span><span class="p">))</span><span class="si">}</span><span class="s1">%</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_cores</span><span class="p">)</span><span class="si">}</span><span class="s1"> -J </span><span class="si">{</span><span class="n">jobname</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="si">}</span><span class="s1"> --wrap &quot;eval </span><span class="si">{</span><span class="nb">chr</span><span class="p">(</span><span class="mi">92</span><span class="p">)</span><span class="si">}</span><span class="s1">`sed -n </span><span class="si">{</span><span class="nb">chr</span><span class="p">(</span><span class="mi">92</span><span class="p">)</span><span class="si">}</span><span class="s1">$</span><span class="se">{{</span><span class="s1">SLURM_ARRAY_TASK_ID</span><span class="se">}}</span><span class="s1">p </span><span class="si">{</span><span class="n">cmdfile</span><span class="si">}{</span><span class="nb">chr</span><span class="p">(</span><span class="mi">92</span><span class="p">)</span><span class="si">}</span><span class="s1">`&quot;&#39;</span>
        
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">jobname</span><span class="si">}</span><span class="s2">_jobstarter.log&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">out_file</span><span class="p">:</span>
            <span class="c1"># Run the sbatch command and direct both stdout and stderr to the log file</span>
            <span class="n">subprocess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">sbatch_cmd</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">out_file</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">out_file</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="c1"># wait for job and clean up</span>
        <span class="k">if</span> <span class="n">wait</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wait_for_job</span><span class="p">(</span><span class="n">jobname</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_cmdfile</span><span class="p">:</span>
            <span class="n">subprocess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;rm </span><span class="si">{</span><span class="n">cmdfile</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="SbatchArrayJobstarter.parse_options">
<a class="viewcode-back" href="../../protflow.html#protflow.jobstarters.SbatchArrayJobstarter.parse_options">[docs]</a>
    <span class="k">def</span> <span class="nf">parse_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parses the SBATCH options.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        options : object</span>
<span class="sd">            SBATCH options in string or list format.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            Parsed SBATCH options.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the options parameter is not a string or list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># parse options</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span> <span class="k">return</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span> <span class="k">return</span> <span class="n">options</span>
        <span class="k">if</span> <span class="n">options</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="s2">&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported type for argument options: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">options</span><span class="p">)</span><span class="si">}</span><span class="s2">. Supported types: [str, list]&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SbatchArrayJobstarter.set_options">
<a class="viewcode-back" href="../../protflow.html#protflow.jobstarters.SbatchArrayJobstarter.set_options">[docs]</a>
    <span class="k">def</span> <span class="nf">set_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span> <span class="n">gpus</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the SBATCH options.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        options : object</span>
<span class="sd">            SBATCH options in string or list format.</span>
<span class="sd">        gpus : int</span>
<span class="sd">            Number of GPUs to be used per node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_options</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gpus</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;--gpus-per-node </span><span class="si">{</span><span class="n">gpus</span><span class="si">}</span><span class="s2"> -c2&quot;</span></div>


<div class="viewcode-block" id="SbatchArrayJobstarter.wait_for_job">
<a class="viewcode-back" href="../../protflow.html#protflow.jobstarters.SbatchArrayJobstarter.wait_for_job">[docs]</a>
    <span class="k">def</span> <span class="nf">wait_for_job</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jobname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">interval</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Waits for SLURM jobs to be finished.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        jobname : str</span>
<span class="sd">            Name of the job to wait for.</span>
<span class="sd">        interval : float, optional</span>
<span class="sd">            Interval (in seconds) at which to check the job status. Default is 5.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if job is running by capturing the length of the output of squeue command that only returns jobs with &lt;jobname&gt;:</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">subprocess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;squeue -n </span><span class="si">{</span><span class="n">jobname</span><span class="si">}</span><span class="s1"> -o &quot;%A&quot;&#39;</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">capture_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Job </span><span class="si">{</span><span class="n">jobname</span><span class="si">}</span><span class="s2"> completed.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>
</div>


<div class="viewcode-block" id="LocalJobStarter">
<a class="viewcode-back" href="../../protflow.html#protflow.jobstarters.LocalJobStarter">[docs]</a>
<span class="k">class</span> <span class="nc">LocalJobStarter</span><span class="p">(</span><span class="n">JobStarter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Jobstarter that runs jobs locally using subprocess.run().</span>

<span class="sd">    This class extends the `JobStarter` base class to provide functionality for running jobs </span>
<span class="sd">    locally on the machine. It handles the execution of commands using subprocesses, manages </span>
<span class="sd">    the maximum number of concurrent processes, and captures the output and error logs for </span>
<span class="sd">    each command.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    __init__(max_cores: int = 1)</span>
<span class="sd">        Initializes the LocalJobStarter with an optional parameter for maximum cores.</span>
<span class="sd">    </span>
<span class="sd">    start(cmds: list, jobname: str, wait: bool = True, output_path: str = None) -&gt; None</span>
<span class="sd">        Submits a list of commands to be run locally, managing the execution and logging </span>
<span class="sd">        of each command.</span>
<span class="sd">    </span>
<span class="sd">    wait_for_job(jobname: str, interval: float) -&gt; None</span>
<span class="sd">        (No-op) Method for waiting for started jobs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    max_cores : int, optional</span>
<span class="sd">        The maximum number of cores that can be used for the jobs. Default is 1.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ProcessError</span>
<span class="sd">        If a subprocess crashes during execution.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Example usage:</span>
<span class="sd">    </span>
<span class="sd">        &gt;&gt;&gt; from jobstarters import LocalJobStarter</span>
<span class="sd">        &gt;&gt;&gt; job_starter = LocalJobStarter(max_cores=2)</span>
<span class="sd">        &gt;&gt;&gt; job_starter.start(cmds=[&quot;echo &#39;Hello World!&#39;&quot;], jobname=&quot;test_job&quot;, wait=True, output_path=&quot;/path/to/output&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="LocalJobStarter.__init__">
<a class="viewcode-back" href="../../protflow.html#protflow.jobstarters.LocalJobStarter.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_cores</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the LocalJobStarter with an optional parameter for maximum cores.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_cores : int, optional</span>
<span class="sd">            The maximum number of cores that can be used for the jobs. Default is 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_cores</span> <span class="o">=</span> <span class="n">max_cores</span></div>


<div class="viewcode-block" id="LocalJobStarter.start">
<a class="viewcode-back" href="../../protflow.html#protflow.jobstarters.LocalJobStarter.start">[docs]</a>
    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmds</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">jobname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">wait</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">output_path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Submits a list of commands to be run locally, managing the execution and logging of each command.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cmds : list</span>
<span class="sd">            List of commands to be executed locally.</span>
<span class="sd">        jobname : str</span>
<span class="sd">            Name of the job.</span>
<span class="sd">        wait : bool, optional</span>
<span class="sd">            Whether to wait for all commands to complete before returning. Default is True.</span>
<span class="sd">        output_path : str, optional</span>
<span class="sd">            Path where output files should be stored. Default is None.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ProcessError</span>
<span class="sd">            If a subprocess crashes during execution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">start_process</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">output_file</span><span class="p">):</span>
            <span class="c1"># Open the file to capture output and error</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">output_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;UTF-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
                <span class="c1"># Start the process</span>
                <span class="n">process</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">Popen</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="n">env</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">file</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">STDOUT</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">process</span>

        <span class="k">def</span> <span class="nf">update_active_processes</span><span class="p">(</span><span class="n">active_processes</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39;checks how many of the processes are active.</span>
<span class="sd">            wait: wait for process to be finished when removing.&#39;&#39;&#39;</span>
            <span class="k">for</span> <span class="n">process</span> <span class="ow">in</span> <span class="n">active_processes</span><span class="p">:</span> <span class="c1"># [:] if copy is required</span>
                <span class="k">if</span> <span class="n">process</span><span class="o">.</span><span class="n">poll</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># process finished</span>
                    <span class="n">returncode</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">returncode</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">ProcessError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Subprocess Crashed. Check last output log of Subprocess!&quot;</span><span class="p">)</span>
                    <span class="n">active_processes</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">process</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">active_processes</span>

        <span class="c1"># collect environment context</span>
        <span class="n">env</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># write cmds to file:</span>
        <span class="n">cmdfile_path</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">jobname</span><span class="si">}</span><span class="s2">_cmds.txt&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">cmdfile_path</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;UTF-8&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cmds</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># invert cmds to start from the top with .pop()</span>
        <span class="n">cmds</span> <span class="o">=</span> <span class="n">cmds</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># initialize job loop</span>
        <span class="n">active_processes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">cmds</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># first check if any processes need to be removed</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">active_processes</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_cores</span><span class="p">:</span>
                <span class="n">update_active_processes</span><span class="p">(</span><span class="n">active_processes</span><span class="p">)</span>
                <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># avoid busy waiting</span>

            <span class="c1"># setup process:</span>
            <span class="n">cmd</span> <span class="o">=</span> <span class="n">cmds</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">output_file</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">/process_</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="si">}</span><span class="s2">.log&quot;</span>

            <span class="c1"># start</span>
            <span class="n">active_processes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start_process</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">output_file</span><span class="p">))</span>

        <span class="c1"># wait for completion loop</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">active_processes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">update_active_processes</span><span class="p">(</span><span class="n">active_processes</span><span class="p">)</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="LocalJobStarter.wait_for_job">
<a class="viewcode-back" href="../../protflow.html#protflow.jobstarters.LocalJobStarter.wait_for_job">[docs]</a>
    <span class="k">def</span> <span class="nf">wait_for_job</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jobname</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">interval</span><span class="p">:</span><span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (No-op) Method for waiting for started jobs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        jobname : str</span>
<span class="sd">            Name of the job to wait for.</span>
<span class="sd">        interval : float</span>
<span class="sd">            Interval (in seconds) at which to check the job status.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span></div>
</div>


<div class="viewcode-block" id="add_timestamp">
<a class="viewcode-back" href="../../protflow.html#protflow.jobstarters.add_timestamp">[docs]</a>
<span class="k">def</span> <span class="nf">add_timestamp</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds a unique timestamp to a string using the time library.</span>

<span class="sd">    This function appends a unique timestamp to the given string. The timestamp is generated</span>
<span class="sd">    using the current time, which ensures that the resulting string is unique in most cases.</span>
<span class="sd">    The timestamp is added as a suffix, separated by an underscore.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : str</span>
<span class="sd">        The input string to which the timestamp will be added.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    str</span>
<span class="sd">        The input string with a unique timestamp appended.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; add_timestamp(&quot;jobname&quot;)</span>
<span class="sd">    &#39;jobname_1632417284&#39;</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The timestamp is derived from the current time in seconds since the epoch, with the</span>
<span class="sd">    fractional part of the seconds included to ensure higher precision and uniqueness.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">())</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">])</span></div>


<div class="viewcode-block" id="split_list">
<a class="viewcode-back" href="../../protflow.html#protflow.jobstarters.split_list">[docs]</a>
<span class="k">def</span> <span class="nf">split_list</span><span class="p">(</span><span class="n">input_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">element_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">n_sublists</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits a list into nested sublists with specified lengths or number of sublists.</span>

<span class="sd">    This function divides the input list into a nested list of sublists. The division can be</span>
<span class="sd">    based on the maximum length of each sublist or the desired number of sublists. Only one</span>
<span class="sd">    of the parameters, `element_length` or `n_sublists`, should be specified at a time.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_list : list</span>
<span class="sd">        The list to be split into sublists.</span>
<span class="sd">    element_length : int, optional</span>
<span class="sd">        The maximum length of each sublist. If specified, the input list will be split</span>
<span class="sd">        into sublists each having up to `element_length` elements.</span>
<span class="sd">    n_sublists : int, optional</span>
<span class="sd">        The desired number of sublists. If specified, the input list will be divided into</span>
<span class="sd">        `n_sublists` sublists.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        A nested list containing the sublists.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If both `element_length` and `n_sublists` are specified or if neither is specified.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Splitting a list into sublists of a specified maximum length:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; split_list([1, 2, 3, 4, 5, 6], element_length=2)</span>
<span class="sd">    [[1, 2], [3, 4], [5, 6]]</span>

<span class="sd">    Splitting a list into a specified number of sublists:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; split_list([1, 2, 3, 4, 5, 6], n_sublists=3)</span>
<span class="sd">    [[1, 2], [3, 4], [5, 6]]</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - If `n_sublists` is specified and is greater than the length of the input list, the number</span>
<span class="sd">      of sublists will be equal to the length of the input list.</span>
<span class="sd">    - If neither `element_length` nor `n_sublists` is provided, or if both are provided,</span>
<span class="sd">      a `ValueError` will be raised.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># safety</span>
    <span class="k">if</span> <span class="n">element_length</span> <span class="ow">and</span> <span class="n">n_sublists</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Only either element_length or n_sublists can be specified, but not both!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">element_length</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">n_sublists</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;At least one of arguments &#39;element_length or n_sublists has to be given!&quot;</span><span class="p">)</span>

    <span class="c1"># handling n_sublists</span>
    <span class="k">if</span> <span class="n">n_sublists</span><span class="p">:</span>
        <span class="c1"># if initial list is shorter than n_sublists, take minimum value</span>
        <span class="n">split_n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">n_sublists</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_list</span><span class="p">)])</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">input_list</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">split_n</span><span class="p">))]</span>

    <span class="c1"># handling element_length</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">iterator</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">input_list</span><span class="p">)</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">sublist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="n">iterator</span><span class="p">,</span> <span class="n">element_length</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sublist</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sublist</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Your Name.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>